<order-form>

    <div class="order-line token-selector button clickable-button" onclick={ openTokenSelector }>{ state.inputToken.symbol } Ë…</div>

    <div class="order-line order-buttons">
        <div id="buy-button" class="buy-button button clickable-button" onclick={ setBuyOrderType }>Buy</div>
        <div id="sell-button" class="sell-button button clickable-button" onclick={ setSellOrderType }>Sell</div>
    </div>

    <div class="order-line">Amount</div>
    <div class="order-line order-input">
        <input type="number" onkeyup={ updateAmount } placeholder="0"/>
        <label>{ state.inputToken.symbol }</label>
    </div>

    <div class="order-line">Price</div>
    <div class="order-line order-input">
        <input type="number" onkeyup={ updatePrice } placeholder="0"/>
        <label>{ state.outputToken.symbol }</label>
    </div>

    <div class="order-line order-info">
        <div>Fee</div>
        <label>{ formattedFeeAmount() } { state.outputToken.symbol }</label>
    </div>
    <div class="order-line order-info">
        <div>Total</div>
        <label>{ formattedTotalAmount() } { state.outputToken.symbol }</label>
    </div>

    <div id ="place-order-button" class="order-line button">
        { state.submitMessage }
    </div>

    <div id="token-selector-box" style="display:none" }>
        <token-selector
                closeTokenSelector={ closeTokenSelector }
                selectToken={ selectToken }
        />
    </div>

    <script>

        import './order_form.css'
        import TokenSelector from '../../token_selector/token_selector.riot'
        import {registerForTokenAllowancesUpdate, tokensList} from "../../../common/token_fetch";
        import {
            setBaseToken,
            setQuoteToken
        } from "../../../common/0x_order_book_proxy";
        import {ZeroXOrdersProxy} from "../../../common/0x_orders_proxy";
        import { BigNumber } from '@0x/utils';
        import {calculateMetricFee, MetricReferralAddress} from "../../../common/metric_fee";
        import { router } from '@riotjs/route'

        export default {
            components: {
                TokenSelector
            },
            config: {
                buyOrderType: "BUY",
                sellOrderType: "SELL"
            },
            state: {
                inputToken: null,
                outputToken: null,
                amount: NaN,
                price: NaN,
                isOutputTokenApproved: false,
                isInputTokenApproved: false,
                showTokenSelector: false
            },
            onBeforeMount(props) {
                this.state.orderType = this.config.buyOrderType

                if (props.tokenAddress !== undefined && props.tokenAddress !== null) {
                    let tokenFromRoute =
                        tokensList().find(t => t.address.toLowerCase() === props.tokenAddress.toLowerCase())

                    if (tokenFromRoute !== undefined && tokenFromRoute !== null) {
                        this.state.inputToken = tokenFromRoute
                        router.push(`/#/${this.state.inputToken.address}`)
                        setBaseToken(this.state.inputToken)
                    }
                }

                this.state.outputToken =
                    tokensList().find(t => t.symbol.toLowerCase() === "dai")

                setQuoteToken(this.state.outputToken)

                this.setOrderMessage()
            },
            async onMounted() {
                registerForTokenAllowancesUpdate(this)
                await this.setBuyOrderType()
            },
            async onTokenAllowancesUpdate() {
                this.update()
            },
            closeTokenSelector() {
                document.getElementById("token-selector-box").style.display = "none"
            },
            openTokenSelector() {
                document.getElementById("token-selector-box").style.display = "block"
                document.getElementById("token-selector-input-text").focus()
            },
            async selectToken(token) {
                router.push(`/#/${token.address}`)

                await setBaseToken(token)
                this.state.inputToken = token

                this.setOrderMessage()
                this.update()

                this.closeTokenSelector()
            },
            updateAmount(e) {
                this.update({ amount: parseFloat(e.target.value) })
                this.updateSubmitButtonState()
            },
            updatePrice(e) {
                this.update({ price: parseFloat(e.target.value) })
                this.updateSubmitButtonState()
            },
            updateSubmitButtonState() {
                this.setOrderMessage()
                let button = document.getElementById("place-order-button")
                if (!this.isValidOrder() || !this.isSufficientBalance()) {
                    button.classList.remove("active-button")
                    button.classList.remove("clickable-button")
                    button.onclick = null
                } else if (this.isValidOrder() && !button.classList.contains("active-button")) {
                    button.classList.add("active-button")
                    button.classList.add("clickable-button")
                    button.onclick = this.checkApprovalAndSubmitOrder
                }
                this.update()
            },
            async setBuyOrderType() {
                this.state.orderType = this.config.buyOrderType
                document.getElementById("sell-button").classList.remove("active-button")
                document.getElementById("buy-button").classList.remove("active-button")
                document.getElementById("buy-button").classList.add("active-button")
                this.setOrderMessage()
                this.update()
            },
            async setSellOrderType() {
                this.state.orderType = this.config.sellOrderType
                document.getElementById("sell-button").classList.remove("active-button")
                document.getElementById("buy-button").classList.remove("active-button")
                document.getElementById("sell-button").classList.add("active-button")
                this.setOrderMessage()
                this.update()
            },
            async checkApprovalAndSubmitOrder() {
                let isApproved = await this.isApproved()

                if (!isApproved) {
                    await this.requestApproval()
                    isApproved = await this.isApproved()
                }
                if (isApproved) {
                    await ZeroXOrdersProxy.submitOrder(
                        this.buildOrder(),
                        MetricReferralAddress,
                        calculateMetricFee()
                    )
                }
            },
            buildOrder() {
                let inputAmount = this.inputAmount() * (10 ** this.state.inputToken.decimals)
                let outputAmount = this.outputAmount() * (10 ** this.state.outputToken.decimals)

                if (this.isSellOrder()) {
                    return {
                        makerAssetAmount: new BigNumber(inputAmount),
                        makerAssetAddress: this.state.inputToken.address,
                        takerAssetAmount: new BigNumber(outputAmount),
                        takerAssetAddress: this.state.outputToken.address
                    }
                } else {
                    return {
                        makerAssetAmount: new BigNumber(outputAmount),
                        makerAssetAddress: this.state.outputToken.address,
                        takerAssetAmount: new BigNumber(inputAmount),
                        takerAssetAddress: this.state.inputToken.address
                    }
                }
            },
            inputAmount() {
                return this.state.amount
            },
            outputAmount() {
                let amount = this.inputAmount()
                return (isNaN(amount) ? 0 : amount) * (isNaN(this.state.price) ? 0 : this.state.price)
            },
            formattedTotalAmount() {
                return ((this.outputAmount() + this.feeAmount())).toFixed(3)
            },
            formattedFeeAmount() {
                return this.feeAmount().toFixed(3)
            },
            feeAmount() {
                let amount = this.outputAmount()
                return this.applyFee((isNaN(amount) ? 0 : amount))
            },
            applyFee(amount) {
                return amount * calculateMetricFee()
            },
            isBuyOrder() {
                return this.state.orderType === this.config.buyOrderType
            },
            isSellOrder() {
                return this.state.orderType === this.config.sellOrderType
            },
            async isApproved() {
                if (this.isBuyOrder()) {
                    return await ZeroXOrdersProxy.is0xApprovedForToken(this.state.outputToken.address, this.outputAmount() * (10 ** this.state.outputToken.decimals))
                } else {
                    return await ZeroXOrdersProxy.is0xApprovedForToken(this.state.inputToken.address, this.inputAmount() * (10 ** this.state.inputToken.decimals))
                }
            },
            requestApproval() {
                if (this.isBuyOrder()) {
                    this.sendApprovalForToken(this.state.outputToken)
                } else {
                    this.sendApprovalForToken(this.state.inputToken)
                }
            },
            sendApprovalForToken(token) {
                this.setApprovalMessage(token)
                ZeroXOrdersProxy.approveZeroXAllowance(
                    token.address,
                    (a, b) => {
                        this.setOrderMessage()
                    },
                    (e) => {
                        this.setOrderMessage()
                    }
                )
            },
            setApprovalMessage(token) {
                this.update({submitMessage: `APPROVING ${token.symbol}`})
            },
            setOrderMessage() {
                if (!this.isValidInputs()) {
                    this.state.submitMessage = "PLACE ORDER"
                } else if (!this.isValidOrder()) {
                    this.state.submitMessage = `MUST BE >${this.state.outputToken.volume_limit} ${this.state.outputToken.symbol}`
                } else if (!this.isSufficientBalance()) {
                    this.state.submitMessage = `INSUFFICIENT BALANCE`
                } else if(!this.maybeIsApproved()) {
                    if (this.isBuyOrder()) {
                        this.state.submitMessage = `APPROVE ${this.state.outputToken.symbol}`
                    }else {
                        this.state.submitMessage = `APPROVE ${this.state.inputToken.symbol}`
                    }
                } else {
                    this.state.submitMessage = "PLACE ORDER"
                }
            },
            maybeIsApproved() {
                if (this.isBuyOrder()) {
                    return tokensList().find(t => t.symbol === this.state.outputToken.symbol).allowance >= this.outputAmount()
                } else {
                    return tokensList().find(t => t.symbol === this.state.inputToken.symbol).allowance >= this.inputAmount()
                }
            },
            isValidOrder() {
                let isAmountAboveThreshold = (this.outputAmount() > this.state.outputToken.volume_limit)
                return this.isValidInputs() && isAmountAboveThreshold
            },
            isValidInputs() {
                return !isNaN(this.state.price) && !isNaN(this.state.amount)
            },
            isSufficientBalance() {
                let balance = 0
                let amount = 0
                if (this.isBuyOrder()) {
                    balance = tokensList().find(t => t.symbol === this.state.outputToken.symbol).balance
                    amount = this.outputAmount()
                } else {
                    balance = tokensList().find(t => t.symbol === this.state.inputToken.symbol).balance
                    amount = this.inputAmount()
                }

                return balance > (amount + this.applyFee(amount))
            }
        }

    </script>

</order-form>
